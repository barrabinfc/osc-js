{"version":3,"file":"osc.browser.min.js","sources":["../src/common/utils.js","../src/common/helpers.js","../src/atomic.js","../src/atomic/int32.js","../src/atomic/float32.js","../src/atomic/string.js","../src/atomic/blob.js","../src/message.js","../src/atomic/timetag.js","../src/bundle.js","../src/packet.js","../src/events.js","../src/osc.js","../src/plugin/wsbrowser.js","../entry/osc.browser.js"],"sourcesContent":["/**\r\n * Check if given object is an integer number\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isInt(n) {\r\n  return Number(n) === n && n % 1 === 0\r\n}\r\n\r\n/**\r\n * Check if given object is a float number\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isFloat(n) {\r\n  return Number(n) === n && n % 1 !== 0\r\n}\r\n\r\n/**\r\n * Check if given object is a string\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isString(n) {\r\n  return typeof n === 'string'\r\n}\r\n\r\n/**\r\n * Check if given object is an array\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isArray(n) {\r\n  return Object.prototype.toString.call(n) === '[object Array]'\r\n}\r\n\r\n/**\r\n * Check if given object is an object\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isObject(n) {\r\n  return Object.prototype.toString.call(n) === '[object Object]'\r\n}\r\n\r\n/**\r\n * Check if given object is a function\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isFunction(n) {\r\n  return typeof n === 'function'\r\n}\r\n\r\n/**\r\n * Check if given object is a Uint8Array\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isBlob(n) {\r\n  return n instanceof Uint8Array\r\n}\r\n\r\n/**\r\n * Check if given object is a Date\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isDate(n) {\r\n  return n instanceof Date\r\n}\r\n\r\n/**\r\n * Check if given object is undefined\r\n * @param {*} n\r\n * @return {boolean}\r\n */\r\nexport function isUndefined(n) {\r\n  return typeof n === 'undefined'\r\n}\r\n\r\n/**\r\n * Return the next multiple of four\r\n * @param {number} n\r\n */\r\nexport function pad(n) {\r\n  return (n + 3) & ~0x03\r\n}\r\n\r\n/**\r\n * Checks if environment provides a feature\r\n * @param {string} name Name of needed feature\r\n * @return {boolean}\r\n */\r\nexport function hasProperty(name) {\r\n  return Object.prototype.hasOwnProperty.call(\r\n    (typeof global !== 'undefined' ? global : window), // eslint-disable-line no-undef\r\n    name\r\n  )\r\n}\r\n\r\n/**\r\n * Wrap binary data in DataView\r\n * @param {*} obj\r\n * @return {DataView}\r\n */\r\nexport function dataView(obj) {\r\n  if (obj.buffer) {\r\n    return new DataView(obj.buffer)\r\n  } else if (obj instanceof ArrayBuffer) {\r\n    return new DataView(obj)\r\n  }\r\n\r\n  return new DataView(new Uint8Array(obj))\r\n}\r\n","import { isArray, isInt, isFloat, isString, isBlob } from './utils'\r\n\r\n/**\r\n * Checks type of given object and returns the regarding OSC\r\n * Type tag character\r\n * @param {*} item Any object\r\n * @return {string} OSC Type tag character\r\n */\r\nexport function typeTag(item) {\r\n  if (isInt(item)) {\r\n    return 'i'\r\n  } else if (isFloat(item)) {\r\n    return 'f'\r\n  } else if (isString(item)) {\r\n    return 's'\r\n  } else if (isBlob(item)) {\r\n    return 'b'\r\n  }\r\n\r\n  throw new Error('OSC typeTag() found unknown value type')\r\n}\r\n\r\n/**\r\n * Sanitizes an OSC-ready Address Pattern\r\n * @param {array|string} obj Address as string or array of strings\r\n * @return {string} Corrected address string\r\n *\r\n * @example\r\n * // all calls return '/test/path' string:\r\n * prepareAddress('test/path')\r\n * prepareAddress('/test/path/')\r\n * prepareAddress([test, path])\r\n */\r\nexport function prepareAddress(obj) {\r\n  let address = ''\r\n\r\n  if (isArray(obj)) {\r\n    return `/${obj.join('/')}`\r\n  } else if (isString(obj)) {\r\n    address = obj\r\n\r\n    // remove slash at ending of address\r\n    if (address.length > 1 && address[address.length - 1] === '/') {\r\n      address = address.slice(0, address.length - 1)\r\n    }\r\n\r\n    // add slash at beginning of address\r\n    if (address.length > 1 && address[0] !== '/') {\r\n      address = `/${address}`\r\n    }\r\n\r\n    return address\r\n  }\r\n\r\n  throw new Error('OSC prepareAddress() needs addresses of type array or string')\r\n}\r\n\r\n/**\r\n * Make an OSC address pattern javascript-regex-ready\r\n * @param {string} str OSC address pattern\r\n * @return {string} Javascript RegEx string\r\n */\r\nexport function prepareRegExPattern(str) {\r\n  let pattern\r\n\r\n  if (!(isString(str))) {\r\n    throw new Error('OSC prepareRegExPattern() needs strings')\r\n  }\r\n\r\n  pattern = str.replace(/\\./g, '\\\\.')\r\n  pattern = pattern.replace(/\\(/g, '\\\\(')\r\n  pattern = pattern.replace(/\\)/g, '\\\\)')\r\n\r\n  pattern = pattern.replace(/\\{/g, '(')\r\n  pattern = pattern.replace(/\\}/g, ')')\r\n  pattern = pattern.replace(/,/g, '|')\r\n\r\n  pattern = pattern.replace(/\\[!/g, '[^')\r\n\r\n  pattern = pattern.replace(/\\?/g, '.')\r\n  pattern = pattern.replace(/\\*/g, '.*')\r\n\r\n  return pattern\r\n}\r\n\r\n/**\r\n * Holds a list of items and helps to merge them\r\n * into a single array of packed binary data\r\n */\r\nexport default class EncodeHelper {\r\n  /**\r\n   * Create a new EncodeHelper instance\r\n   */\r\n  constructor() {\r\n    /** @type {array} data */\r\n    this.data = []\r\n    /** @type {number} byteLength */\r\n    this.byteLength = 0\r\n  }\r\n\r\n  /**\r\n   * Packs an item and adds it to the list\r\n   * @param {*} item Any object\r\n   * @return {EncodeHelper}\r\n   */\r\n  add(item) {\r\n    const buffer = item.pack()\r\n    this.byteLength += buffer.byteLength\r\n    this.data.push(buffer)\r\n\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Merge all added items into one Uint8Array\r\n   * @return {Uint8Array} Merged binary data array of all items\r\n   */\r\n  merge() {\r\n    const result = new Uint8Array(this.byteLength)\r\n    let offset = 0\r\n\r\n    this.data.forEach((data) => {\r\n      result.set(data, offset)\r\n      offset += data.byteLength\r\n    })\r\n\r\n    return result\r\n  }\r\n}\r\n","import { isUndefined } from './common/utils'\r\n\r\n/**\r\n * Base class for OSC Atomic Data Types\r\n */\r\nexport default class Atomic {\r\n  /**\r\n   * Create an Atomic instance\r\n   * @param {*} [value] Initial value of any type\r\n   */\r\n  constructor(value) {\r\n    /** @type {*} value */\r\n    this.value = value\r\n    /** @type {number} offset */\r\n    this.offset = 0\r\n  }\r\n\r\n  /**\r\n   * Interpret the given value of this entity as packed binary data\r\n   * @param {string} method The DataView method to write to the ArrayBuffer\r\n   * @param {number} byteLength Size of array in bytes\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack(method, byteLength) {\r\n    if (!(method && byteLength)) {\r\n      throw new Error('OSC Atomic cant\\'t be packed without given method or byteLength')\r\n    }\r\n\r\n    const data = new Uint8Array(byteLength)\r\n    const dataView = new DataView(data.buffer)\r\n\r\n    if (isUndefined(this.value)) {\r\n      throw new Error('OSC Atomic cant\\'t be encoded with empty value')\r\n    }\r\n\r\n    // use DataView to write to ArrayBuffer\r\n    dataView[method](this.offset, this.value, false)\r\n\r\n    // always return binary Uint8Array after packing\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data from DataView according to the given format\r\n   * @param {DataView} dataView The DataView holding the binary representation of the value\r\n   * @param {string} method The DataView method to read the format from the ArrayBuffer\r\n   * @param {number} byteLength Size of array in bytes\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, method, byteLength, initialOffset = 0) {\r\n    if (!(dataView && method && byteLength)) {\r\n      throw new Error('OSC Atomic cant\\'t be unpacked without given dataView, method or byteLength')\r\n    }\r\n\r\n    if (!(dataView instanceof DataView)) {\r\n      throw new Error('OSC Atomic expects an instance of type DataView')\r\n    }\r\n\r\n    // use DataView to read from ArrayBuffer and add offset\r\n    this.value = dataView[method](initialOffset, false)\r\n    this.offset = initialOffset + byteLength\r\n\r\n    // always return offset number after unpacking\r\n    return this.offset\r\n  }\r\n}\r\n","import { isInt } from '../common/utils'\r\n\r\nimport Atomic from '../atomic'\r\n\r\n/**\r\n * 32-bit big-endian two's complement integer OSC Atomic Data Type\r\n */\r\nexport default class AtomicInt32 extends Atomic {\r\n  /**\r\n   * Create an AtomicInt32 instance\r\n   * @param {number} [value] Initial integer value\r\n   */\r\n  constructor(value) {\r\n    if (value && !isInt(value)) {\r\n      throw new Error('OSC AtomicInt32 constructor expects value of type number')\r\n    }\r\n\r\n    super(value)\r\n  }\r\n\r\n  /**\r\n   * Interpret the given number as packed binary data\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack() {\r\n    return super.pack('setInt32', 4)\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data from DataView and read a Int32 number\r\n   * @param {DataView} dataView The DataView holding the binary representation of the value\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    return super.unpack(dataView, 'getInt32', 4, initialOffset)\r\n  }\r\n}\r\n","import { isFloat } from '../common/utils'\r\n\r\nimport Atomic from '../atomic'\r\n\r\n/**\r\n * 32-bit big-endian IEEE 754 floating point number OSC Atomic Data Type\r\n */\r\nexport default class AtomicFloat32 extends Atomic {\r\n  /**\r\n   * Create an AtomicFloat32 instance\r\n   * @param {number} [value] Float number\r\n   */\r\n  constructor(value) {\r\n    if (value && !isFloat(value)) {\r\n      throw new Error('OSC AtomicFloat32 constructor expects value of type float')\r\n    }\r\n\r\n    super(value)\r\n  }\r\n\r\n  /**\r\n   * Interpret the given number as packed binary data\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack() {\r\n    return super.pack('setFloat32', 4)\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data from DataView and read a Float32 number\r\n   * @param {DataView} dataView The DataView holding the binary representation of the value\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    return super.unpack(dataView, 'getFloat32', 4, initialOffset)\r\n  }\r\n}\r\n","import { pad, isString, isUndefined, hasProperty } from '../common/utils'\r\n\r\nimport Atomic from '../atomic'\r\n\r\n/** Slice size of large strings for fallback method */\r\nconst STR_SLICE_SIZE = 65537\r\n\r\n/** Text encoding format */\r\nconst STR_ENCODING = 'utf-8'\r\n\r\n/**\r\n * Helper method to decode a string using different methods depending on environment\r\n * @param {array} charCodes Array of char codes\r\n * @return {string} Decoded string\r\n */\r\nfunction charCodesToString(charCodes) {\r\n  // Use these methods to be able to convert large strings\r\n  if (hasProperty('Buffer')) {\r\n    return Buffer.from(charCodes).toString(STR_ENCODING)\r\n  } else if (hasProperty('TextDecoder')) {\r\n    return new TextDecoder(STR_ENCODING) // eslint-disable-line no-undef\r\n      .decode(new Int8Array(charCodes))\r\n  }\r\n\r\n  // Fallback method\r\n  let str = ''\r\n\r\n  for (let i = 0; i < charCodes.length; i += STR_SLICE_SIZE) {\r\n    str += String.fromCharCode.apply(\r\n      null,\r\n      charCodes.slice(i, i + STR_SLICE_SIZE)\r\n    )\r\n  }\r\n\r\n  return str\r\n}\r\n\r\n/**\r\n * A sequence of non-null ASCII characters OSC Atomic Data Type\r\n */\r\nexport default class AtomicString extends Atomic {\r\n  /**\r\n   * Create an AtomicString instance\r\n   * @param {string} [value] Initial string value\r\n   */\r\n  constructor(value) {\r\n    if (value && !isString(value)) {\r\n      throw new Error('OSC AtomicString constructor expects value of type string')\r\n    }\r\n\r\n    super(value)\r\n  }\r\n\r\n  /**\r\n   * Interpret the given string as packed binary data\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack() {\r\n    if (isUndefined(this.value)) {\r\n      throw new Error('OSC AtomicString can not be encoded with empty value')\r\n    }\r\n\r\n    // add 0-3 null characters for total number of bits a multiple of 32\r\n    const terminated = `${this.value}\\u0000`\r\n    const byteLength = pad(terminated.length)\r\n\r\n    const buffer = new Uint8Array(byteLength)\r\n\r\n    for (let i = 0; i < terminated.length; i += 1) {\r\n      buffer[i] = terminated.charCodeAt(i)\r\n    }\r\n\r\n    return buffer\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data from DataView and read a string\r\n   * @param {DataView} dataView The DataView holding the binary representation of the string\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    if (!(dataView instanceof DataView)) {\r\n      throw new Error('OSC AtomicString expects an instance of type DataView')\r\n    }\r\n\r\n    let offset = initialOffset\r\n    let charcode\r\n    const charCodes = []\r\n\r\n    for (; offset < dataView.byteLength; offset += 1) {\r\n      charcode = dataView.getUint8(offset)\r\n\r\n      // check for terminating null character\r\n      if (charcode !== 0) {\r\n        charCodes.push(charcode)\r\n      } else {\r\n        offset += 1\r\n        break\r\n      }\r\n    }\r\n\r\n    if (offset === dataView.length) {\r\n      throw new Error('OSC AtomicString found a malformed OSC string')\r\n    }\r\n\r\n    /** @type {number} offset */\r\n    this.offset = pad(offset)\r\n    /** @type {string} value */\r\n    this.value = charCodesToString(charCodes)\r\n\r\n    return this.offset\r\n  }\r\n}\r\n","import { pad, isBlob, isUndefined } from '../common/utils'\r\n\r\nimport Atomic from '../atomic'\r\n\r\n/**\r\n * 8-bit bytes of arbitrary binary data OSC Atomic Data Type\r\n */\r\nexport default class AtomicBlob extends Atomic {\r\n  /**\r\n   * Create an AtomicBlob instance\r\n   * @param {Uint8Array} [value] Binary data\r\n   */\r\n  constructor(value) {\r\n    if (value && !isBlob(value)) {\r\n      throw new Error('OSC AtomicBlob constructor expects value of type Uint8Array')\r\n    }\r\n\r\n    super(value)\r\n  }\r\n\r\n  /**\r\n   * Interpret the given blob as packed binary data\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack() {\r\n    if (isUndefined(this.value)) {\r\n      throw new Error('OSC AtomicBlob can not be encoded with empty value')\r\n    }\r\n\r\n    const byteLength = pad(this.value.byteLength)\r\n    const data = new Uint8Array(byteLength + 4)\r\n    const dataView = new DataView(data.buffer)\r\n\r\n    // an int32 size count\r\n    dataView.setInt32(0, this.value.byteLength, false)\r\n    // followed by 8-bit bytes of arbitrary binary data\r\n    data.set(this.value, 4)\r\n\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data from DataView and read a blob\r\n   * @param {DataView} dataView The DataView holding the binary representation of the blob\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    if (!(dataView instanceof DataView)) {\r\n      throw new Error('OSC AtomicBlob expects an instance of type DataView')\r\n    }\r\n\r\n    const byteLength = dataView.getInt32(initialOffset, false)\r\n\r\n    /** @type {Uint8Array} value */\r\n    this.value = new Uint8Array(dataView.buffer, initialOffset + 4, byteLength)\r\n    /** @type {number} offset */\r\n    this.offset = pad(initialOffset + 4 + byteLength)\r\n\r\n    return this.offset\r\n  }\r\n}\r\n","import {\r\n  isArray,\r\n  isBlob,\r\n  isFloat,\r\n  isInt,\r\n  isString,\r\n  isUndefined,\r\n} from './common/utils'\r\n\r\nimport Helper, { typeTag, prepareAddress } from './common/helpers'\r\n\r\nimport AtomicInt32 from './atomic/int32'\r\nimport AtomicFloat32 from './atomic/float32'\r\nimport AtomicString from './atomic/string'\r\nimport AtomicBlob from './atomic/blob'\r\n\r\n/**\r\n * An OSC message consists of an OSC Address Pattern followed\r\n * by an OSC Type Tag String followed by zero or more OSC Arguments\r\n */\r\nexport default class Message {\r\n  /**\r\n   * Create a Message instance\r\n   * @param {array|string} args Address\r\n   * @param {...*} args OSC Atomic Data Types\r\n   *\r\n   * @example\r\n   * const message = new Message(['test', 'path'], 50, 100.52, 'test')\r\n   *\r\n   * @example\r\n   * const message = new Message('/test/path', 51.2)\r\n   */\r\n  constructor(...args) {\r\n    /**\r\n     * @type {number} offset\r\n     * @private\r\n     */\r\n    this.offset = 0\r\n    /** @type {string} address */\r\n    this.address = ''\r\n    /** @type {string} types */\r\n    this.types = ''\r\n    /** @type {array} args */\r\n    this.args = []\r\n\r\n    if (args.length > 0) {\r\n      if (!(isString(args[0]) || isArray(args[0]))) {\r\n        throw new Error('OSC Message constructor first argument (address) must be a string or array')\r\n      }\r\n\r\n      this.address = prepareAddress(args.shift())\r\n      this.types = args.map(item => typeTag(item)).join('')\r\n      this.args = args\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add an OSC Atomic Data Type to the list of elements\r\n   * @param {*} item\r\n   */\r\n  add(item) {\r\n    if (isUndefined(item)) {\r\n      throw new Error('OSC Message needs a valid OSC Atomic Data Type')\r\n    }\r\n\r\n    this.args.push(item)\r\n    this.types += typeTag(item)\r\n  }\r\n\r\n  /**\r\n   * Interpret the Message as packed binary data\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack() {\r\n    if (this.address.length === 0 || this.address[0] !== '/') {\r\n      throw new Error('OSC Message has an invalid address')\r\n    }\r\n\r\n    const encoder = new Helper()\r\n\r\n    // OSC Address Pattern and Type string\r\n    encoder.add(new AtomicString(this.address))\r\n    encoder.add(new AtomicString(`,${this.types}`))\r\n\r\n    // followed by zero or more OSC Arguments\r\n    if (this.args.length > 0) {\r\n      let argument\r\n\r\n      this.args.forEach((value) => {\r\n        if (isInt(value)) {\r\n          argument = new AtomicInt32(value)\r\n        } else if (isFloat(value)) {\r\n          argument = new AtomicFloat32(value)\r\n        } else if (isString(value)) {\r\n          argument = new AtomicString(value)\r\n        } else if (isBlob(value)) {\r\n          argument = new AtomicBlob(value)\r\n        } else {\r\n          throw new Error('OSC Message found unknown argument type')\r\n        }\r\n\r\n        encoder.add(argument)\r\n      })\r\n    }\r\n\r\n    return encoder.merge()\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data to read a Message\r\n   * @param {DataView} dataView The DataView holding the binary representation of a Message\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    if (!(dataView instanceof DataView)) {\r\n      throw new Error('OSC Message expects an instance of type DataView.')\r\n    }\r\n\r\n    // read address pattern\r\n    const address = new AtomicString()\r\n    address.unpack(dataView, initialOffset)\r\n\r\n    // read type string\r\n    const types = new AtomicString()\r\n    types.unpack(dataView, address.offset)\r\n\r\n    if (address.value.length === 0 || address.value[0] !== '/') {\r\n      throw new Error('OSC Message found malformed or missing address string')\r\n    }\r\n\r\n    if (types.value.length === 0 && types.value[0] !== ',') {\r\n      throw new Error('OSC Message found malformed or missing type string')\r\n    }\r\n\r\n    let { offset } = types\r\n    let next\r\n    let type\r\n\r\n    const args = []\r\n\r\n    // read message arguments (OSC Atomic Data Types)\r\n    for (let i = 1; i < types.value.length; i += 1) {\r\n      type = types.value[i]\r\n\r\n      if (type === 'i') {\r\n        next = new AtomicInt32()\r\n      } else if (type === 'f') {\r\n        next = new AtomicFloat32()\r\n      } else if (type === 's') {\r\n        next = new AtomicString()\r\n      } else if (type === 'b') {\r\n        next = new AtomicBlob()\r\n      } else {\r\n        throw new Error('OSC Message found non-standard argument type')\r\n      }\r\n\r\n      offset = next.unpack(dataView, offset)\r\n      args.push(next.value)\r\n    }\r\n\r\n    this.offset = offset\r\n    this.address = address.value\r\n    this.types = types.value\r\n    this.args = args\r\n\r\n    return this.offset\r\n  }\r\n}\r\n","import { isInt, isDate, isUndefined } from '../common/utils'\r\n\r\nimport Atomic from '../atomic'\r\n\r\n/** 70 years in seconds */\r\nexport const SECONDS_70_YEARS = 2208988800\r\n/** 2^32 */\r\nexport const TWO_POWER_32 = 4294967296\r\n\r\n/**\r\n * Timetag helper class for representing NTP timestamps\r\n * and conversion between them and javascript representation\r\n */\r\nexport class Timetag {\r\n  /**\r\n   * Create a Timetag instance\r\n   * @param {number} [seconds=0] Initial NTP *seconds* value\r\n   * @param {number} [fractions=0] Initial NTP *fractions* value\r\n   */\r\n  constructor(seconds = 0, fractions = 0) {\r\n    if (!(isInt(seconds) && isInt(fractions))) {\r\n      throw new Error('OSC Timetag constructor expects values of type integer number')\r\n    }\r\n\r\n    /** @type {number} seconds */\r\n    this.seconds = seconds\r\n    /** @type {number} fractions */\r\n    this.fractions = fractions\r\n  }\r\n\r\n  /**\r\n   * Converts from NTP to JS representation and back\r\n   * @param {number} [milliseconds] Converts from JS milliseconds to NTP.\r\n   * Leave empty for converting from NTP to JavaScript representation\r\n   * @return {number} Javascript timestamp\r\n   */\r\n  timestamp(milliseconds) {\r\n    let seconds\r\n\r\n    if (typeof milliseconds === 'number') {\r\n      seconds = milliseconds / 1000\r\n      const rounded = Math.floor(seconds)\r\n\r\n      this.seconds = rounded + SECONDS_70_YEARS\r\n      this.fractions = Math.round(TWO_POWER_32 * (seconds - rounded))\r\n\r\n      return milliseconds\r\n    }\r\n\r\n    seconds = this.seconds - SECONDS_70_YEARS\r\n    return (seconds + Math.round(this.fractions / TWO_POWER_32)) * 1000\r\n  }\r\n}\r\n\r\n/**\r\n * 64-bit big-endian fixed-point time tag, semantics\r\n * defined below OSC Atomic Data Type\r\n */\r\nexport default class AtomicTimetag extends Atomic {\r\n  /**\r\n   * Create a AtomicTimetag instance\r\n   * @param {number|Timetag|Date} [value] Initial date, leave empty if\r\n   * you want it to be the current date\r\n   */\r\n  constructor(value = Date.now()) {\r\n    let timetag = new Timetag()\r\n\r\n    if (value instanceof Timetag) {\r\n      timetag = value\r\n    } else if (isInt(value)) {\r\n      timetag.timestamp(value)\r\n    } else if (isDate(value)) {\r\n      timetag.timestamp(value.getTime())\r\n    }\r\n\r\n    super(timetag)\r\n  }\r\n\r\n  /**\r\n   * Interpret the given timetag as packed binary data\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack() {\r\n    if (isUndefined(this.value)) {\r\n      throw new Error('OSC AtomicTimetag can not be encoded with empty value')\r\n    }\r\n\r\n    const { seconds, fractions } = this.value\r\n    const data = new Uint8Array(8)\r\n    const dataView = new DataView(data.buffer)\r\n\r\n    dataView.setInt32(0, seconds, false)\r\n    dataView.setInt32(4, fractions, false)\r\n\r\n    return data\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data from DataView and read a timetag\r\n   * @param {DataView} dataView The DataView holding the binary representation of the timetag\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    if (!(dataView instanceof DataView)) {\r\n      throw new Error('OSC AtomicTimetag expects an instance of type DataView')\r\n    }\r\n\r\n    const seconds = dataView.getUint32(initialOffset, false)\r\n    const fractions = dataView.getUint32(initialOffset + 4, false)\r\n\r\n    /** @type {Timetag} value */\r\n    this.value = new Timetag(seconds, fractions)\r\n    /** @type {number} offset */\r\n    this.offset = initialOffset + 8\r\n\r\n    return this.offset\r\n  }\r\n}\r\n","import { isArray, isInt } from './common/utils'\r\nimport EncodeHelper from './common/helpers'\r\n\r\nimport Packet from './packet'\r\nimport Message from './message'\r\nimport AtomicString from './atomic/string'\r\nimport AtomicInt32 from './atomic/int32'\r\nimport AtomicTimetag from './atomic/timetag'\r\n\r\n/** OSC Bundle string */\r\nexport const BUNDLE_TAG = '#bundle'\r\n\r\n/**\r\n * An OSC Bundle consist of a Timetag and one or many Bundle Elements.\r\n * The elements are either OSC Messages or more OSC Bundles\r\n */\r\nexport default class Bundle {\r\n  /**\r\n   * Create a Bundle instance\r\n   * @param {...*} [args] Timetag and elements. See examples for options\r\n   *\r\n   * @example\r\n   * const bundle = new Bundle(new Date() + 500)\r\n   *\r\n   * @example\r\n   * const message = new Message('/test/path', 51.2)\r\n   * const anotherBundle = new Bundle([message], Date.now() + 1500)\r\n   *\r\n   * @example\r\n   * const message = new Message('/test/path', 51.2)\r\n   * const anotherMessage = new Message('/test/message', 'test', 12)\r\n   * const anotherBundle = new Bundle(message, anotherMessage)\r\n   */\r\n  constructor(...args) {\r\n    /**\r\n     * @type {number} offset\r\n     * @private\r\n     */\r\n    this.offset = 0\r\n    /** @type {AtomicTimetag} timetag */\r\n    this.timetag = new AtomicTimetag()\r\n    /** @type {array} bundleElements */\r\n    this.bundleElements = []\r\n\r\n    if (args.length > 0) {\r\n      // first argument is an Date or js timestamp (number)\r\n      if (args[0] instanceof Date || isInt(args[0])) {\r\n        this.timetag = new AtomicTimetag(args[0])\r\n      } else if (isArray(args[0])) {\r\n        // first argument is an Array of Bundle elements\r\n        args[0].forEach((item) => {\r\n          this.add(item)\r\n        })\r\n\r\n        // second argument is an Date or js timestamp (number)\r\n        if (args.length > 1 && (args[1] instanceof Date || isInt(args[0]))) {\r\n          this.timetag = new AtomicTimetag(args[1])\r\n        }\r\n      } else {\r\n        // take all arguments as Bundle elements\r\n        args.forEach((item) => {\r\n          this.add(item)\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Take a JavaScript timestamp to set the Bundle's timetag\r\n   * @param {number} ms JS timestamp in milliseconds\r\n   *\r\n   * @example\r\n   * const bundle = new Bundle()\r\n   * bundle.timestamp(Date.now() + 5000) // in 5 seconds\r\n   */\r\n  timestamp(ms) {\r\n    if (!isInt(ms)) {\r\n      throw new Error('OSC Bundle needs an integer for setting the timestamp')\r\n    }\r\n\r\n    this.timetag = new AtomicTimetag(ms)\r\n  }\r\n\r\n  /**\r\n   * Add a Message or Bundle to the list of elements\r\n   * @param {Bundle|Message} item\r\n   */\r\n  add(item) {\r\n    if (!(item instanceof Message || item instanceof Bundle)) {\r\n      throw new Error('OSC Bundle contains only Messages and Bundles')\r\n    }\r\n\r\n    this.bundleElements.push(item)\r\n  }\r\n\r\n  /**\r\n   * Interpret the Bundle as packed binary data\r\n   * @return {Uint8Array} Packed binary data\r\n   */\r\n  pack() {\r\n    const encoder = new EncodeHelper()\r\n\r\n    // an OSC Bundle consists of the OSC-string \"#bundle\"\r\n    encoder.add(new AtomicString(BUNDLE_TAG))\r\n\r\n    // followed by an OSC Time Tag\r\n    if (!this.timetag) {\r\n      this.timetag = new AtomicTimetag()\r\n    }\r\n\r\n    encoder.add(this.timetag)\r\n\r\n    // followed by zero or more OSC Bundle Elements\r\n    this.bundleElements.forEach((item) => {\r\n      encoder.add(new AtomicInt32(item.pack().byteLength))\r\n      encoder.add(item)\r\n    })\r\n\r\n    return encoder.merge()\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data to read a Bundle\r\n   * @param {DataView} dataView The DataView holding the binary representation of a Bundle\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    if (!(dataView instanceof DataView)) {\r\n      throw new Error('OSC Bundle expects an instance of type DataView')\r\n    }\r\n\r\n    // read the beginning bundle string\r\n    const head = new AtomicString()\r\n    head.unpack(dataView, initialOffset)\r\n\r\n    if (head.value !== BUNDLE_TAG) {\r\n      throw new Error('OSC Bundle does not contain a valid #bundle head')\r\n    }\r\n\r\n    // read the timetag\r\n    const timetag = new AtomicTimetag()\r\n    let offset = timetag.unpack(dataView, head.offset)\r\n\r\n    // read the bundle elements\r\n    this.bundleElements = []\r\n\r\n    while (offset < dataView.byteLength) {\r\n      const packet = new Packet()\r\n      const size = new AtomicInt32()\r\n\r\n      offset = size.unpack(dataView, offset)\r\n      offset = packet.unpack(dataView, offset, this.timetag)\r\n\r\n      this.bundleElements.push(packet.value)\r\n    }\r\n\r\n    this.offset = offset\r\n    this.timetag = timetag\r\n\r\n    return this.offset\r\n  }\r\n}\r\n","import Bundle, { BUNDLE_TAG } from './bundle'\r\nimport Message from './message'\r\nimport AtomicString from './atomic/string'\r\n\r\n/**\r\n * The unit of transmission of OSC is an OSC Packet. The contents\r\n * of an OSC packet must be either an OSC Message or an OSC Bundle\r\n */\r\nexport default class Packet {\r\n  /**\r\n   * Create a Packet instance holding a Message or Bundle\r\n   * @param {Message|Bundle} [value] Initial Packet value\r\n   */\r\n  constructor(value) {\r\n    if (value && !(value instanceof Message || value instanceof Bundle)) {\r\n      throw new Error('OSC Packet value has to be Message or Bundle')\r\n    }\r\n\r\n    /** @type {Message|Bundle} value */\r\n    this.value = value\r\n    /**\r\n     * @type {number} offset\r\n     * @private\r\n     */\r\n    this.offset = 0\r\n  }\r\n\r\n  /**\r\n   * Packs the Packet value. This implementation is more like\r\n   * a wrapper due to OSC specifications, you could also skip the\r\n   * Packet and directly work with the Message or Bundle instance\r\n   * @return {Uint8Array} Packed binary data\r\n   *\r\n   * @example\r\n   * const message = new Message('/test/path', 21.5, 'test')\r\n   * const packet = new Packet(message)\r\n   * const packetBinary = packet.pack() // then send it via udp etc.\r\n   *\r\n   * // or skip the Packet for convenience\r\n   * const messageBinary = message.pack()\r\n   */\r\n  pack() {\r\n    if (!this.value) {\r\n      throw new Error('OSC Packet can not be encoded with empty body')\r\n    }\r\n\r\n    return this.value.pack()\r\n  }\r\n\r\n  /**\r\n   * Unpack binary data from DataView to read Messages or Bundles\r\n   * @param {DataView} dataView The DataView holding a binary representation of a Packet\r\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\r\n   * @return {number} Offset after unpacking\r\n   */\r\n  unpack(dataView, initialOffset = 0) {\r\n    if (!(dataView instanceof DataView)) {\r\n      throw new Error('OSC Packet expects an instance of type DataView')\r\n    }\r\n\r\n    if (dataView.byteLength % 4 !== 0) {\r\n      throw new Error('OSC Packet byteLength has to be a multiple of four')\r\n    }\r\n\r\n    const head = new AtomicString()\r\n    head.unpack(dataView, initialOffset)\r\n\r\n    let item\r\n\r\n    // check if Packet is a Bundle or a Message\r\n    if (head.value === BUNDLE_TAG) {\r\n      item = new Bundle()\r\n    } else {\r\n      item = new Message()\r\n    }\r\n\r\n    item.unpack(dataView, initialOffset)\r\n\r\n    this.offset = item.offset\r\n    this.value = item\r\n\r\n    return this.offset\r\n  }\r\n}\r\n","import { isArray, isString, isInt, isFunction, dataView } from './common/utils'\r\nimport { prepareAddress, prepareRegExPattern } from './common/helpers'\r\n\r\nimport Packet from './packet'\r\nimport Bundle from './bundle'\r\nimport Message from './message'\r\n\r\n/**\r\n * Default options\r\n * @private\r\n */\r\nconst defaultOptions = {\r\n  discardLateMessages: false,\r\n}\r\n\r\n/**\r\n * EventHandler to notify listeners on matching OSC messages and\r\n * status changes of plugins\r\n */\r\nexport default class EventHandler {\r\n  /**\r\n   * Create an EventHandler instance\r\n   * @param {object} options Custom options\r\n   */\r\n  constructor(options) {\r\n    /**\r\n     * @type {object} options\r\n     * @private\r\n     */\r\n    this.options = Object.assign({}, defaultOptions, options)\r\n    /**\r\n     * @type {array} addressHandlers\r\n     * @private\r\n     */\r\n    this.addressHandlers = []\r\n    /**\r\n     * @type {object} eventHandlers\r\n     * @private\r\n     */\r\n    this.eventHandlers = {\r\n      open: [],\r\n      error: [],\r\n      close: [],\r\n    }\r\n    /**\r\n     * @type {number} uuid\r\n     * @private\r\n     */\r\n    this.uuid = 0\r\n  }\r\n\r\n  /**\r\n   * Internally used method to dispatch OSC Packets. Extracts\r\n   * given Timetags and dispatches them accordingly\r\n   * @param {Packet} packet\r\n   * @return {boolean} Success state\r\n   * @private\r\n   */\r\n  dispatch(packet) {\r\n    if (!(packet instanceof Packet)) {\r\n      throw new Error('OSC EventHander dispatch() accepts only arguments of type Packet')\r\n    }\r\n\r\n    if (!packet.value) {\r\n      throw new Error('OSC EventHander dispatch() can\\'t read empty Packets')\r\n    }\r\n\r\n    if (packet.value instanceof Bundle) {\r\n      const bundle = packet.value\r\n\r\n      return bundle.bundleElements.forEach((bundleItem) => {\r\n        if (bundleItem instanceof Bundle) {\r\n          if (bundle.timetag.value.timestamp() < bundleItem.timetag.value.timestamp()) {\r\n            throw new Error('OSC Bundle timestamp is older than the timestamp of enclosed Bundles')\r\n          }\r\n          return this.dispatch(bundleItem)\r\n        } else if (bundleItem instanceof Message) {\r\n          const message = bundleItem\r\n          return this.notify(\r\n            message.address,\r\n            message,\r\n            bundle.timetag.value.timestamp()\r\n          )\r\n        }\r\n\r\n        throw new Error('OSC EventHander dispatch() can\\'t dispatch unknown Packet value')\r\n      })\r\n    } else if (packet.value instanceof Message) {\r\n      const message = packet.value\r\n      return this.notify(message.address, message)\r\n    }\r\n\r\n    throw new Error('OSC EventHander dispatch() can\\'t dispatch unknown Packet value')\r\n  }\r\n\r\n  /**\r\n   * Internally used method to invoke listener callbacks. Uses regular\r\n   * expression pattern matching for OSC addresses\r\n   * @param {string} name OSC address or event name\r\n   * @param {*} [data] The data of the event\r\n   * @return {boolean} Success state\r\n   * @private\r\n   */\r\n  call(name, data) {\r\n    let success = false\r\n\r\n    // call event handlers\r\n    if (isString(name) && name in this.eventHandlers) {\r\n      this.eventHandlers[name].forEach((handler) => {\r\n        handler.callback(data)\r\n        success = true\r\n      })\r\n\r\n      return success\r\n    }\r\n\r\n    // call address handlers\r\n    const handlerKeys = Object.keys(this.addressHandlers)\r\n    const handlers = this.addressHandlers\r\n\r\n    handlerKeys.forEach((key) => {\r\n      const regex = new RegExp(prepareRegExPattern(prepareAddress(name)), 'g')\r\n      const test = regex.test(key)\r\n\r\n      // found a matching address in our callback handlers\r\n      if (test && key.length === regex.lastIndex) {\r\n        handlers[key].forEach((handler) => {\r\n          handler.callback(data)\r\n          success = true\r\n        })\r\n      }\r\n    })\r\n\r\n    return success\r\n  }\r\n\r\n  /**\r\n   * Notify the EventHandler of incoming OSC messages or status\r\n   * changes (*open*, *close*, *error*). Handles OSC address patterns\r\n   * and executes timed messages. Use binary arrays when\r\n   * handling directly incoming network data. Packet's or Messages can\r\n   * also be used\r\n   * @param {...*} args\r\n   * The OSC address pattern / event name as string}. For convenience and\r\n   * Plugin API communication you can also use Message or Packet instances\r\n   * or ArrayBuffer, Buffer instances (low-level access). The latter will\r\n   * automatically be unpacked\r\n   * When using a string you can also pass on data as a second argument\r\n   * (any type). All regarding listeners will be notified with this data.\r\n   * As a third argument you can define a javascript timestamp (number or\r\n   * Date instance) for timed notification of the listeners.\r\n   * @return {boolean} Success state of notification\r\n   *\r\n   * @example\r\n   * const socket = dgram.createSocket('udp4')\r\n   * socket.on('message', (message) => {\r\n   *   this.notify(message)\r\n   * })\r\n   *\r\n   * @example\r\n   * this.notify('error', error.message)\r\n   *\r\n   * @example\r\n   * const message = new OSC.Message('/test/path', 55)\r\n   * this.notify(message)\r\n   *\r\n   * @example\r\n   * const message = new OSC.Message('/test/path', 55)\r\n   * // override timestamp\r\n   * this.notify(message.address, message, Date.now() + 5000)\r\n   */\r\n  notify(...args) {\r\n    if (args.length === 0) {\r\n      throw new Error('OSC EventHandler can not be called without any argument')\r\n    }\r\n\r\n    // check for incoming dispatchable OSC data\r\n    if (args[0] instanceof Packet) {\r\n      return this.dispatch(args[0])\r\n    } else if (args[0] instanceof Bundle || args[0] instanceof Message) {\r\n      return this.dispatch(new Packet(args[0]))\r\n    } else if (!isString(args[0])) {\r\n      const packet = new Packet()\r\n      packet.unpack(dataView(args[0]))\r\n      return this.dispatch(packet)\r\n    }\r\n\r\n    const name = args[0]\r\n\r\n    // data argument\r\n    let data = null\r\n\r\n    if (args.length > 1) {\r\n      data = args[1]\r\n    }\r\n\r\n    // timestamp argument\r\n    let timestamp = null\r\n\r\n    if (args.length > 2) {\r\n      if (isInt(args[2])) {\r\n        timestamp = args[2]\r\n      } else if (args[2] instanceof Date) {\r\n        timestamp = args[2].getTime()\r\n      } else {\r\n        throw new Error('OSC EventHandler timestamp has to be a number or Date')\r\n      }\r\n    }\r\n\r\n    // notify now or later\r\n    if (timestamp) {\r\n      const now = Date.now()\r\n\r\n      // is message outdated?\r\n      if (now > timestamp) {\r\n        if (!this.options.discardLateMessages) {\r\n          return this.call(name, data)\r\n        }\r\n      }\r\n\r\n      // notify later\r\n      const that = this\r\n\r\n      setTimeout(() => {\r\n        that.call(name, data)\r\n      }, timestamp - now)\r\n\r\n      return true\r\n    }\r\n\r\n    return this.call(name, data)\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a new address or event you want to listen to\r\n   * @param {string} name The OSC address or event name\r\n   * @param {function} callback Callback function on notification\r\n   * @return {number} Subscription identifier (needed to unsubscribe)\r\n   */\r\n  on(name, callback) {\r\n    if (!(isString(name) || isArray(name))) {\r\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns')\r\n    }\r\n\r\n    if (!isFunction(callback)) {\r\n      throw new Error('OSC EventHandler callback has to be a function')\r\n    }\r\n\r\n    // get next id\r\n    this.uuid += 1\r\n\r\n    // prepare handler\r\n    const handler = {\r\n      id: this.uuid,\r\n      callback,\r\n    }\r\n\r\n    // register event listener\r\n    if (isString(name) && name in this.eventHandlers) {\r\n      this.eventHandlers[name].push(handler)\r\n      return this.uuid\r\n    }\r\n\r\n    // register address listener\r\n    const address = prepareAddress(name)\r\n    const regex = new RegExp(/[#*\\s[\\],/{}|?]/g)\r\n\r\n    if (regex.test(address.split('/').join(''))) {\r\n      throw new Error('OSC EventHandler address string contains invalid characters')\r\n    }\r\n\r\n    if (!(address in this.addressHandlers)) {\r\n      this.addressHandlers[address] = []\r\n    }\r\n\r\n    this.addressHandlers[address].push(handler)\r\n\r\n    return this.uuid\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe listener from event notification or address handler\r\n   * @param {string} name The OSC address or event name\r\n   * @param {number} subscriptionId Subscription id to identify the handler\r\n   * @return {boolean} Success state\r\n   */\r\n  off(name, subscriptionId) {\r\n    if (!(isString(name) || isArray(name))) {\r\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns')\r\n    }\r\n\r\n    if (!isInt(subscriptionId)) {\r\n      throw new Error('OSC EventHandler subscription id has to be a number')\r\n    }\r\n\r\n    let key\r\n    let haystack\r\n\r\n    // event or address listener\r\n    if (isString(name) && name in this.eventHandlers) {\r\n      key = name\r\n      haystack = this.eventHandlers\r\n    } else {\r\n      key = prepareAddress(name)\r\n      haystack = this.addressHandlers\r\n    }\r\n\r\n    // remove the entry\r\n    if (key in haystack) {\r\n      return haystack[key].some((item, index) => {\r\n        if (item.id === subscriptionId) {\r\n          haystack[key].splice(index, 1)\r\n          return true\r\n        }\r\n\r\n        return false\r\n      })\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n","import { isObject, isString, isFunction, isInt } from './common/utils'\r\n\r\nimport Packet from './packet'\r\nimport Bundle from './bundle'\r\nimport Message from './message'\r\n\r\nimport EventHandler from './events'\r\n\r\n/**\r\n * Default options\r\n * @private\r\n */\r\nconst defaultOptions = {\r\n  plugin: null,\r\n  discardLateMessages: false,\r\n}\r\n\r\n/**\r\n * Status flags\r\n */\r\nconst STATUS = {\r\n  IS_NOT_INITIALIZED: -1,\r\n  IS_CONNECTING: 0,\r\n  IS_OPEN: 1,\r\n  IS_CLOSING: 2,\r\n  IS_CLOSED: 3,\r\n}\r\n\r\n/**\r\n * OSC interface to send OSC Packets and to listen to status-changes and\r\n * incoming message events. Offers a Plugin API for different network\r\n * protocols, defaults to a simple Websocket client for OSC communication\r\n * between a browser js-app and a js-node server\r\n *\r\n * @example\r\n * const osc = new OSC()\r\n *\r\n * osc.on('/input/test', (message) => {\r\n *   // print incoming OSC message arguments\r\n *   console.log(message.args)\r\n * })\r\n *\r\n * osc.on('open', () => {\r\n *   const message = new Message('/test/path', 55.12, 'hello')\r\n *   osc.send(message)\r\n * })\r\n *\r\n * osc.open({ host: '192.168.178.115', port: 9012 })\r\n */\r\nclass OSC {\r\n  /**\r\n   * Create an OSC instance with given options\r\n   * @param {object} [options] Custom options\r\n   * @param {boolean} [options.discardLateMessages=false] Ignore incoming\r\n   * messages when given timetag lies in the past\r\n   * @param {Plugin} [options.plugin=WebsocketClientPlugin] Add a connection plugin\r\n   * to this interface, defaults to a plugin with Websocket client.\r\n   * Open README.md for further information on how to handle plugins or\r\n   * how to write your own with the Plugin API\r\n   *\r\n   * @example\r\n   * const osc = new OSC() // default options with Websocket client\r\n   *\r\n   * @example\r\n   * const osc = new OSC({ discardLateMessages: true })\r\n   *\r\n   * @example\r\n   * const websocketPlugin = new OSC.WebsocketClientPlugin()\r\n   * const osc = new OSC({ plugin: websocketPlugin })\r\n   */\r\n  constructor(options) {\r\n    if (options && !isObject(options)) {\r\n      throw new Error('OSC options argument has to be an object.')\r\n    }\r\n\r\n    /**\r\n     * @type {object} options\r\n     * @private\r\n     */\r\n    this.options = Object.assign({}, defaultOptions, options)\r\n    /**\r\n     * @type {EventHandler} eventHandler\r\n     * @private\r\n     */\r\n    this.eventHandler = new EventHandler({\r\n      discardLateMessages: this.options.discardLateMessages,\r\n    })\r\n\r\n    // pass EventHandler's notify() to plugin\r\n    const { eventHandler } = this\r\n    if (this.options.plugin && this.options.plugin.registerNotify) {\r\n      this.options.plugin.registerNotify((...args) => eventHandler.notify(...args))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Listen to a status-change event or incoming OSC message with\r\n   * address pattern matching\r\n   * @param {string} eventName Event name or OSC address pattern\r\n   * @param {function} callback Function which is called on notification\r\n   * @return {number} Subscription id (needed to unsubscribe)\r\n   *\r\n   * @example\r\n   * // will be called when server receives /in!trument/* for example\r\n   * osc.on('/instrument/1', (message) => {\r\n   *   console.log(message)\r\n   * })\r\n   *\r\n   * @example\r\n   * // will be called on network socket error\r\n   * osc.on('error', (message) => {\r\n   *   console.log(message)\r\n   * })\r\n   */\r\n  on(eventName, callback) {\r\n    if (!(isString(eventName) && isFunction(callback))) {\r\n      throw new Error('OSC on() needs event- or address string and callback function')\r\n    }\r\n\r\n    return this.eventHandler.on(eventName, callback)\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe an event listener\r\n   * @param {string} eventName Event name or OSC address pattern\r\n   * @param {number} subscriptionId The subscription id\r\n   * @return {boolean} Success state\r\n   *\r\n   * @example\r\n   * const listenerId = osc.on('error', (message) => {\r\n   *   console.log(message)\r\n   * })\r\n   * osc.off('error', listenerId) // unsubscribe from error event\r\n   */\r\n  off(eventName, subscriptionId) {\r\n    if (!(isString(eventName) && isInt(subscriptionId))) {\r\n      throw new Error('OSC off() needs string and number (subscriptionId) to unsubscribe')\r\n    }\r\n\r\n    return this.eventHandler.off(eventName, subscriptionId)\r\n  }\r\n\r\n  /**\r\n   * Open network socket with plugin. This method is used by\r\n   * plugins and is not available without (see Plugin API for more information)\r\n   * @param {object} [options] Custom global options for plugin instance\r\n   *\r\n   * @example\r\n   * const osc = new OSC({ plugin: new OSC.DatagramPlugin() })\r\n   * osc.open({ host: '127.0.0.1', port: 8080 })\r\n   */\r\n  open(options) {\r\n    if (options && !isObject(options)) {\r\n      throw new Error('OSC open() options argument needs to be an object')\r\n    }\r\n\r\n    if (!(this.options.plugin && isFunction(this.options.plugin.open))) {\r\n      throw new Error('OSC Plugin API #open is not implemented!')\r\n    }\r\n\r\n    return this.options.plugin.open(options)\r\n  }\r\n\r\n  /**\r\n   * Returns the current status of the connection. See *STATUS* for\r\n   * different possible states. This method is used by plugins\r\n   * and is not available without (see Plugin API for more information)\r\n   * @return {number} Status identifier\r\n   *\r\n   * @example\r\n   * import OSC, { STATUS } from 'osc'\r\n   * const osc = new OSC()\r\n   * if (osc.status() === STATUS.IS_CONNECTING) {\r\n   *   // do something\r\n   * }\r\n   */\r\n  status() {\r\n    if (!(this.options.plugin && isFunction(this.options.plugin.status))) {\r\n      throw new Error('OSC Plugin API #status is not implemented!')\r\n    }\r\n\r\n    return this.options.plugin.status()\r\n  }\r\n\r\n  /**\r\n   * Close connection. This method is used by plugins and is not\r\n   * available without (see Plugin API for more information)\r\n   */\r\n  close() {\r\n    if (!(this.options.plugin && isFunction(this.options.plugin.close))) {\r\n      throw new Error('OSC Plugin API #close is not implemented!')\r\n    }\r\n\r\n    return this.options.plugin.close()\r\n  }\r\n\r\n  /**\r\n   * Send an OSC Packet, Bundle or Message. This method is used by plugins\r\n   * and is not available without (see Plugin API for more information)\r\n   * @param {Packet|Bundle|Message} packet OSC Packet, Bundle or Message instance\r\n   * @param {object} [options] Custom options\r\n   *\r\n   * @example\r\n   * const osc = new OSC({ plugin: new OSC.DatagramPlugin() })\r\n   * osc.open({ host: '127.0.0.1', port: 8080 })\r\n   *\r\n   * const message = new OSC.Message('/test/path', 55.1, 57)\r\n   * osc.send(message)\r\n   *\r\n   * // send message again to custom address\r\n   * osc.send(message, { host: '192.168.178.115', port: 9001 })\r\n   */\r\n  send(packet, options) {\r\n    if (!(this.options.plugin && isFunction(this.options.plugin.send))) {\r\n      throw new Error('OSC Plugin API #send is not implemented!')\r\n    }\r\n\r\n    if (!(packet instanceof Message || packet instanceof Bundle || packet instanceof Packet)) {\r\n      throw new Error('OSC send() needs Messages, Bundles or Packets')\r\n    }\r\n\r\n    if (options && !isObject(options)) {\r\n      throw new Error('OSC send() options argument has to be an object')\r\n    }\r\n\r\n    return this.options.plugin.send(packet.pack(), options)\r\n  }\r\n}\r\n\r\n// expose status flags\r\nOSC.STATUS = STATUS\r\n\r\n// expose OSC classes\r\nOSC.Packet = Packet\r\nOSC.Bundle = Bundle\r\nOSC.Message = Message\r\n\r\nexport default OSC\r\n","import { hasProperty } from '../common/utils'\r\n\r\n/**\r\n * Status flags\r\n * @private\r\n */\r\nconst STATUS = {\r\n  IS_NOT_INITIALIZED: -1,\r\n  IS_CONNECTING: 0,\r\n  IS_OPEN: 1,\r\n  IS_CLOSING: 2,\r\n  IS_CLOSED: 3,\r\n}\r\n\r\n/**\r\n * Default options\r\n * @private\r\n */\r\nconst defaultOptions = {\r\n  host: 'localhost',\r\n  port: 8080,\r\n  secure: false,\r\n}\r\n\r\n/**\r\n * OSC plugin for a Websocket client running in only browser contexts\r\n */\r\nexport default class WebsocketBrowserPlugin {\r\n  /**\r\n   * Create an OSC WebsocketBrowserPlugin instance with given options.\r\n   * Defaults to *localhost:8080* for connecting to a Websocket server\r\n   * @param {object} [options] Custom options\r\n   * @param {string} [options.host='localhost'] Hostname of Websocket server\r\n   * @param {number} [options.port=8080] Port of Websocket server\r\n   * @param {boolean} [options.secure=false] Use wss:// for secure connections\r\n   *\r\n   * @example\r\n   * const plugin = new OSC.WebsocketBrowserPlugin({ port: 9912 })\r\n   * const osc = new OSC({ plugin: plugin })\r\n   */\r\n  constructor(customOptions) {\r\n    if (!hasProperty('WebSocket')) { // eslint-disable-line no-undef\r\n      throw new Error('WebsocketBrowserPlugin can\\'t find a WebSocket class')\r\n    }\r\n\r\n    /**\r\n     * @type {object} options\r\n     * @private\r\n     */\r\n    this.options = Object.assign({}, defaultOptions, customOptions)\r\n\r\n    /**\r\n     * @type {object} socket\r\n     * @private\r\n     */\r\n    this.socket = null\r\n    /**\r\n     * @type {number} socketStatus\r\n     * @private\r\n     */\r\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\r\n\r\n    /**\r\n     * @type {function} notify\r\n     * @private\r\n     */\r\n    this.notify = () => {}\r\n  }\r\n\r\n  /**\r\n   * Internal method to hook into osc library's\r\n   * EventHandler notify method\r\n   * @param {function} fn Notify callback\r\n   * @private\r\n   */\r\n  registerNotify(fn) {\r\n    this.notify = fn\r\n  }\r\n\r\n  /**\r\n   * Returns the current status of the connection\r\n   * @return {number} Status identifier\r\n   */\r\n  status() {\r\n    return this.socketStatus\r\n  }\r\n\r\n  /**\r\n   * Connect to a Websocket server. Defaults to global options\r\n   * @param {object} [customOptions] Custom options\r\n   * @param {string} [customOptions.host] Hostname of Websocket server\r\n   * @param {number} [customOptions.port] Port of Websocket server\r\n   * @param {boolean} [customOptions.secure] Use wss:// for secure connections\r\n   */\r\n  open(customOptions = {}) {\r\n    const options = Object.assign({}, this.options, customOptions)\r\n    const { port, host, secure } = options\r\n\r\n    // close socket when already given\r\n    if (this.socket) {\r\n      this.close()\r\n    }\r\n\r\n    // create websocket client\r\n    const protocol = secure ? 'wss' : 'ws'\r\n    this.socket = new WebSocket(`${protocol}://${host}:${port}`) // eslint-disable-line no-undef\r\n    this.socket.binaryType = 'arraybuffer'\r\n    this.socketStatus = STATUS.IS_CONNECTING\r\n\r\n    // register events\r\n    this.socket.onopen = () => {\r\n      this.socketStatus = STATUS.IS_OPEN\r\n      this.notify('open')\r\n    }\r\n\r\n    this.socket.onclose = () => {\r\n      this.socketStatus = STATUS.IS_CLOSED\r\n      this.notify('close')\r\n    }\r\n\r\n    this.socket.onerror = (error) => {\r\n      this.notify('error', error)\r\n    }\r\n\r\n    this.socket.onmessage = (message) => {\r\n      this.notify(message.data)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close Websocket\r\n   */\r\n  close() {\r\n    this.socketStatus = STATUS.IS_CLOSING\r\n    this.socket.close()\r\n  }\r\n\r\n  /**\r\n   * Send an OSC Packet, Bundle or Message to Websocket server\r\n   * @param {Uint8Array} binary Binary representation of OSC Packet\r\n   */\r\n  send(binary) {\r\n    this.socket.send(binary)\r\n  }\r\n}\r\n","import OSCBase from '../src/osc'\r\n\r\nimport WebsocketBrowserPlugin from '../src/plugin/wsbrowser'\r\n\r\nconst defaultOptions = {\r\n  plugin: new WebsocketBrowserPlugin(),\r\n}\r\n\r\nclass OSC extends OSCBase {\r\n  constructor(options) {\r\n    super(Object.assign({}, defaultOptions, options))\r\n  }\r\n}\r\n\r\nOSC.WebsocketBrowserPlugin = WebsocketBrowserPlugin\r\n\r\nexport default OSC\r\n"],"names":["isInt","n","Number","isFloat","isString","isArray","Object","prototype","toString","call","isObject","isFunction","isBlob","Uint8Array","isUndefined","pad","hasProperty","name","hasOwnProperty","global","window","typeTag","item","Error","prepareAddress","obj","address","join","length","slice","EncodeHelper","data","byteLength","buffer","pack","push","this","result","offset","forEach","set","Atomic","value","method","dataView","DataView","initialOffset","AtomicInt32","AtomicFloat32","STR_SLICE_SIZE","STR_ENCODING","AtomicString","terminated","i","charCodeAt","charcode","charCodes","getUint8","Buffer","from","TextDecoder","decode","Int8Array","str","String","fromCharCode","apply","charCodesToString","AtomicBlob","setInt32","getInt32","Message","types","args","shift","map","encoder","Helper","add","argument","merge","unpack","next","type","SECONDS_70_YEARS","TWO_POWER_32","Timetag","seconds","fractions","milliseconds","rounded","Math","floor","round","AtomicTimetag","Date","now","timetag","timestamp","getTime","getUint32","BUNDLE_TAG","Bundle","bundleElements","ms","head","packet","Packet","defaultOptions","EventHandler","options","assign","addressHandlers","eventHandlers","uuid","bundle","bundleItem","_this","dispatch","message","notify","success","handler","callback","handlerKeys","keys","handlers","key","regex","RegExp","replace","prepareRegExPattern","test","lastIndex","ArrayBuffer","discardLateMessages","that","split","subscriptionId","haystack","some","index","id","splice","OSC","eventHandler","plugin","registerNotify","eventName","on","off","open","status","close","send","STATUS","WebsocketBrowserPlugin","customOptions","socket","socketStatus","IS_NOT_INITIALIZED","fn","port","host","secure","protocol","WebSocket","binaryType","IS_CONNECTING","onopen","IS_OPEN","onclose","IS_CLOSED","onerror","error","onmessage","IS_CLOSING","binary","OSCBase"],"mappings":"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"}